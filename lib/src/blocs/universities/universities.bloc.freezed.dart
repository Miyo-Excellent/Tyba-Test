// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'universities.bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$UniversitiesEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Future<void> Function(List<UniversityModel>) onDone)
        fetchData,
    required TResult Function(UniversityModel university) addPhoto,
    required TResult Function(List<UniversityModel> universities) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Future<void> Function(List<UniversityModel>) onDone)?
        fetchData,
    TResult Function(UniversityModel university)? addPhoto,
    TResult Function(List<UniversityModel> universities)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Future<void> Function(List<UniversityModel>) onDone)?
        fetchData,
    TResult Function(UniversityModel university)? addPhoto,
    TResult Function(List<UniversityModel> universities)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UniversitiesInitialEvent value) initial,
    required TResult Function(_UniversitiesFetchDataEvent value) fetchData,
    required TResult Function(_UniversitiesAddPhotoEvent value) addPhoto,
    required TResult Function(_UniversitiesLoadedEvent value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UniversitiesInitialEvent value)? initial,
    TResult Function(_UniversitiesFetchDataEvent value)? fetchData,
    TResult Function(_UniversitiesAddPhotoEvent value)? addPhoto,
    TResult Function(_UniversitiesLoadedEvent value)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UniversitiesInitialEvent value)? initial,
    TResult Function(_UniversitiesFetchDataEvent value)? fetchData,
    TResult Function(_UniversitiesAddPhotoEvent value)? addPhoto,
    TResult Function(_UniversitiesLoadedEvent value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UniversitiesEventCopyWith<$Res> {
  factory $UniversitiesEventCopyWith(
          UniversitiesEvent value, $Res Function(UniversitiesEvent) then) =
      _$UniversitiesEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$UniversitiesEventCopyWithImpl<$Res>
    implements $UniversitiesEventCopyWith<$Res> {
  _$UniversitiesEventCopyWithImpl(this._value, this._then);

  final UniversitiesEvent _value;
  // ignore: unused_field
  final $Res Function(UniversitiesEvent) _then;
}

/// @nodoc
abstract class _$$_UniversitiesInitialEventCopyWith<$Res> {
  factory _$$_UniversitiesInitialEventCopyWith(
          _$_UniversitiesInitialEvent value,
          $Res Function(_$_UniversitiesInitialEvent) then) =
      __$$_UniversitiesInitialEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UniversitiesInitialEventCopyWithImpl<$Res>
    extends _$UniversitiesEventCopyWithImpl<$Res>
    implements _$$_UniversitiesInitialEventCopyWith<$Res> {
  __$$_UniversitiesInitialEventCopyWithImpl(_$_UniversitiesInitialEvent _value,
      $Res Function(_$_UniversitiesInitialEvent) _then)
      : super(_value, (v) => _then(v as _$_UniversitiesInitialEvent));

  @override
  _$_UniversitiesInitialEvent get _value =>
      super._value as _$_UniversitiesInitialEvent;
}

/// @nodoc

class _$_UniversitiesInitialEvent implements _UniversitiesInitialEvent {
  const _$_UniversitiesInitialEvent();

  @override
  String toString() {
    return 'UniversitiesEvent.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UniversitiesInitialEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Future<void> Function(List<UniversityModel>) onDone)
        fetchData,
    required TResult Function(UniversityModel university) addPhoto,
    required TResult Function(List<UniversityModel> universities) loaded,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Future<void> Function(List<UniversityModel>) onDone)?
        fetchData,
    TResult Function(UniversityModel university)? addPhoto,
    TResult Function(List<UniversityModel> universities)? loaded,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Future<void> Function(List<UniversityModel>) onDone)?
        fetchData,
    TResult Function(UniversityModel university)? addPhoto,
    TResult Function(List<UniversityModel> universities)? loaded,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UniversitiesInitialEvent value) initial,
    required TResult Function(_UniversitiesFetchDataEvent value) fetchData,
    required TResult Function(_UniversitiesAddPhotoEvent value) addPhoto,
    required TResult Function(_UniversitiesLoadedEvent value) loaded,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UniversitiesInitialEvent value)? initial,
    TResult Function(_UniversitiesFetchDataEvent value)? fetchData,
    TResult Function(_UniversitiesAddPhotoEvent value)? addPhoto,
    TResult Function(_UniversitiesLoadedEvent value)? loaded,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UniversitiesInitialEvent value)? initial,
    TResult Function(_UniversitiesFetchDataEvent value)? fetchData,
    TResult Function(_UniversitiesAddPhotoEvent value)? addPhoto,
    TResult Function(_UniversitiesLoadedEvent value)? loaded,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _UniversitiesInitialEvent implements UniversitiesEvent {
  const factory _UniversitiesInitialEvent() = _$_UniversitiesInitialEvent;
}

/// @nodoc
abstract class _$$_UniversitiesFetchDataEventCopyWith<$Res> {
  factory _$$_UniversitiesFetchDataEventCopyWith(
          _$_UniversitiesFetchDataEvent value,
          $Res Function(_$_UniversitiesFetchDataEvent) then) =
      __$$_UniversitiesFetchDataEventCopyWithImpl<$Res>;
  $Res call({Future<void> Function(List<UniversityModel>) onDone});
}

/// @nodoc
class __$$_UniversitiesFetchDataEventCopyWithImpl<$Res>
    extends _$UniversitiesEventCopyWithImpl<$Res>
    implements _$$_UniversitiesFetchDataEventCopyWith<$Res> {
  __$$_UniversitiesFetchDataEventCopyWithImpl(
      _$_UniversitiesFetchDataEvent _value,
      $Res Function(_$_UniversitiesFetchDataEvent) _then)
      : super(_value, (v) => _then(v as _$_UniversitiesFetchDataEvent));

  @override
  _$_UniversitiesFetchDataEvent get _value =>
      super._value as _$_UniversitiesFetchDataEvent;

  @override
  $Res call({
    Object? onDone = freezed,
  }) {
    return _then(_$_UniversitiesFetchDataEvent(
      onDone == freezed
          ? _value.onDone
          : onDone // ignore: cast_nullable_to_non_nullable
              as Future<void> Function(List<UniversityModel>),
    ));
  }
}

/// @nodoc

class _$_UniversitiesFetchDataEvent implements _UniversitiesFetchDataEvent {
  const _$_UniversitiesFetchDataEvent(this.onDone);

  @override
  final Future<void> Function(List<UniversityModel>) onDone;

  @override
  String toString() {
    return 'UniversitiesEvent.fetchData(onDone: $onDone)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UniversitiesFetchDataEvent &&
            (identical(other.onDone, onDone) || other.onDone == onDone));
  }

  @override
  int get hashCode => Object.hash(runtimeType, onDone);

  @JsonKey(ignore: true)
  @override
  _$$_UniversitiesFetchDataEventCopyWith<_$_UniversitiesFetchDataEvent>
      get copyWith => __$$_UniversitiesFetchDataEventCopyWithImpl<
          _$_UniversitiesFetchDataEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Future<void> Function(List<UniversityModel>) onDone)
        fetchData,
    required TResult Function(UniversityModel university) addPhoto,
    required TResult Function(List<UniversityModel> universities) loaded,
  }) {
    return fetchData(onDone);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Future<void> Function(List<UniversityModel>) onDone)?
        fetchData,
    TResult Function(UniversityModel university)? addPhoto,
    TResult Function(List<UniversityModel> universities)? loaded,
  }) {
    return fetchData?.call(onDone);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Future<void> Function(List<UniversityModel>) onDone)?
        fetchData,
    TResult Function(UniversityModel university)? addPhoto,
    TResult Function(List<UniversityModel> universities)? loaded,
    required TResult orElse(),
  }) {
    if (fetchData != null) {
      return fetchData(onDone);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UniversitiesInitialEvent value) initial,
    required TResult Function(_UniversitiesFetchDataEvent value) fetchData,
    required TResult Function(_UniversitiesAddPhotoEvent value) addPhoto,
    required TResult Function(_UniversitiesLoadedEvent value) loaded,
  }) {
    return fetchData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UniversitiesInitialEvent value)? initial,
    TResult Function(_UniversitiesFetchDataEvent value)? fetchData,
    TResult Function(_UniversitiesAddPhotoEvent value)? addPhoto,
    TResult Function(_UniversitiesLoadedEvent value)? loaded,
  }) {
    return fetchData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UniversitiesInitialEvent value)? initial,
    TResult Function(_UniversitiesFetchDataEvent value)? fetchData,
    TResult Function(_UniversitiesAddPhotoEvent value)? addPhoto,
    TResult Function(_UniversitiesLoadedEvent value)? loaded,
    required TResult orElse(),
  }) {
    if (fetchData != null) {
      return fetchData(this);
    }
    return orElse();
  }
}

abstract class _UniversitiesFetchDataEvent implements UniversitiesEvent {
  const factory _UniversitiesFetchDataEvent(
          final Future<void> Function(List<UniversityModel>) onDone) =
      _$_UniversitiesFetchDataEvent;

  Future<void> Function(List<UniversityModel>) get onDone;
  @JsonKey(ignore: true)
  _$$_UniversitiesFetchDataEventCopyWith<_$_UniversitiesFetchDataEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UniversitiesAddPhotoEventCopyWith<$Res> {
  factory _$$_UniversitiesAddPhotoEventCopyWith(
          _$_UniversitiesAddPhotoEvent value,
          $Res Function(_$_UniversitiesAddPhotoEvent) then) =
      __$$_UniversitiesAddPhotoEventCopyWithImpl<$Res>;
  $Res call({UniversityModel university});

  $UniversityModelCopyWith<$Res> get university;
}

/// @nodoc
class __$$_UniversitiesAddPhotoEventCopyWithImpl<$Res>
    extends _$UniversitiesEventCopyWithImpl<$Res>
    implements _$$_UniversitiesAddPhotoEventCopyWith<$Res> {
  __$$_UniversitiesAddPhotoEventCopyWithImpl(
      _$_UniversitiesAddPhotoEvent _value,
      $Res Function(_$_UniversitiesAddPhotoEvent) _then)
      : super(_value, (v) => _then(v as _$_UniversitiesAddPhotoEvent));

  @override
  _$_UniversitiesAddPhotoEvent get _value =>
      super._value as _$_UniversitiesAddPhotoEvent;

  @override
  $Res call({
    Object? university = freezed,
  }) {
    return _then(_$_UniversitiesAddPhotoEvent(
      university: university == freezed
          ? _value.university
          : university // ignore: cast_nullable_to_non_nullable
              as UniversityModel,
    ));
  }

  @override
  $UniversityModelCopyWith<$Res> get university {
    return $UniversityModelCopyWith<$Res>(_value.university, (value) {
      return _then(_value.copyWith(university: value));
    });
  }
}

/// @nodoc

class _$_UniversitiesAddPhotoEvent implements _UniversitiesAddPhotoEvent {
  const _$_UniversitiesAddPhotoEvent({required this.university});

  @override
  final UniversityModel university;

  @override
  String toString() {
    return 'UniversitiesEvent.addPhoto(university: $university)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UniversitiesAddPhotoEvent &&
            const DeepCollectionEquality()
                .equals(other.university, university));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(university));

  @JsonKey(ignore: true)
  @override
  _$$_UniversitiesAddPhotoEventCopyWith<_$_UniversitiesAddPhotoEvent>
      get copyWith => __$$_UniversitiesAddPhotoEventCopyWithImpl<
          _$_UniversitiesAddPhotoEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Future<void> Function(List<UniversityModel>) onDone)
        fetchData,
    required TResult Function(UniversityModel university) addPhoto,
    required TResult Function(List<UniversityModel> universities) loaded,
  }) {
    return addPhoto(university);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Future<void> Function(List<UniversityModel>) onDone)?
        fetchData,
    TResult Function(UniversityModel university)? addPhoto,
    TResult Function(List<UniversityModel> universities)? loaded,
  }) {
    return addPhoto?.call(university);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Future<void> Function(List<UniversityModel>) onDone)?
        fetchData,
    TResult Function(UniversityModel university)? addPhoto,
    TResult Function(List<UniversityModel> universities)? loaded,
    required TResult orElse(),
  }) {
    if (addPhoto != null) {
      return addPhoto(university);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UniversitiesInitialEvent value) initial,
    required TResult Function(_UniversitiesFetchDataEvent value) fetchData,
    required TResult Function(_UniversitiesAddPhotoEvent value) addPhoto,
    required TResult Function(_UniversitiesLoadedEvent value) loaded,
  }) {
    return addPhoto(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UniversitiesInitialEvent value)? initial,
    TResult Function(_UniversitiesFetchDataEvent value)? fetchData,
    TResult Function(_UniversitiesAddPhotoEvent value)? addPhoto,
    TResult Function(_UniversitiesLoadedEvent value)? loaded,
  }) {
    return addPhoto?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UniversitiesInitialEvent value)? initial,
    TResult Function(_UniversitiesFetchDataEvent value)? fetchData,
    TResult Function(_UniversitiesAddPhotoEvent value)? addPhoto,
    TResult Function(_UniversitiesLoadedEvent value)? loaded,
    required TResult orElse(),
  }) {
    if (addPhoto != null) {
      return addPhoto(this);
    }
    return orElse();
  }
}

abstract class _UniversitiesAddPhotoEvent implements UniversitiesEvent {
  const factory _UniversitiesAddPhotoEvent(
          {required final UniversityModel university}) =
      _$_UniversitiesAddPhotoEvent;

  UniversityModel get university;
  @JsonKey(ignore: true)
  _$$_UniversitiesAddPhotoEventCopyWith<_$_UniversitiesAddPhotoEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UniversitiesLoadedEventCopyWith<$Res> {
  factory _$$_UniversitiesLoadedEventCopyWith(_$_UniversitiesLoadedEvent value,
          $Res Function(_$_UniversitiesLoadedEvent) then) =
      __$$_UniversitiesLoadedEventCopyWithImpl<$Res>;
  $Res call({List<UniversityModel> universities});
}

/// @nodoc
class __$$_UniversitiesLoadedEventCopyWithImpl<$Res>
    extends _$UniversitiesEventCopyWithImpl<$Res>
    implements _$$_UniversitiesLoadedEventCopyWith<$Res> {
  __$$_UniversitiesLoadedEventCopyWithImpl(_$_UniversitiesLoadedEvent _value,
      $Res Function(_$_UniversitiesLoadedEvent) _then)
      : super(_value, (v) => _then(v as _$_UniversitiesLoadedEvent));

  @override
  _$_UniversitiesLoadedEvent get _value =>
      super._value as _$_UniversitiesLoadedEvent;

  @override
  $Res call({
    Object? universities = freezed,
  }) {
    return _then(_$_UniversitiesLoadedEvent(
      universities == freezed
          ? _value._universities
          : universities // ignore: cast_nullable_to_non_nullable
              as List<UniversityModel>,
    ));
  }
}

/// @nodoc

class _$_UniversitiesLoadedEvent implements _UniversitiesLoadedEvent {
  const _$_UniversitiesLoadedEvent(final List<UniversityModel> universities)
      : _universities = universities;

  final List<UniversityModel> _universities;
  @override
  List<UniversityModel> get universities {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_universities);
  }

  @override
  String toString() {
    return 'UniversitiesEvent.loaded(universities: $universities)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UniversitiesLoadedEvent &&
            const DeepCollectionEquality()
                .equals(other._universities, _universities));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_universities));

  @JsonKey(ignore: true)
  @override
  _$$_UniversitiesLoadedEventCopyWith<_$_UniversitiesLoadedEvent>
      get copyWith =>
          __$$_UniversitiesLoadedEventCopyWithImpl<_$_UniversitiesLoadedEvent>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Future<void> Function(List<UniversityModel>) onDone)
        fetchData,
    required TResult Function(UniversityModel university) addPhoto,
    required TResult Function(List<UniversityModel> universities) loaded,
  }) {
    return loaded(universities);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Future<void> Function(List<UniversityModel>) onDone)?
        fetchData,
    TResult Function(UniversityModel university)? addPhoto,
    TResult Function(List<UniversityModel> universities)? loaded,
  }) {
    return loaded?.call(universities);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Future<void> Function(List<UniversityModel>) onDone)?
        fetchData,
    TResult Function(UniversityModel university)? addPhoto,
    TResult Function(List<UniversityModel> universities)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(universities);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UniversitiesInitialEvent value) initial,
    required TResult Function(_UniversitiesFetchDataEvent value) fetchData,
    required TResult Function(_UniversitiesAddPhotoEvent value) addPhoto,
    required TResult Function(_UniversitiesLoadedEvent value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UniversitiesInitialEvent value)? initial,
    TResult Function(_UniversitiesFetchDataEvent value)? fetchData,
    TResult Function(_UniversitiesAddPhotoEvent value)? addPhoto,
    TResult Function(_UniversitiesLoadedEvent value)? loaded,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UniversitiesInitialEvent value)? initial,
    TResult Function(_UniversitiesFetchDataEvent value)? fetchData,
    TResult Function(_UniversitiesAddPhotoEvent value)? addPhoto,
    TResult Function(_UniversitiesLoadedEvent value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _UniversitiesLoadedEvent implements UniversitiesEvent {
  const factory _UniversitiesLoadedEvent(
      final List<UniversityModel> universities) = _$_UniversitiesLoadedEvent;

  List<UniversityModel> get universities;
  @JsonKey(ignore: true)
  _$$_UniversitiesLoadedEventCopyWith<_$_UniversitiesLoadedEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UniversitiesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<UniversityModel> universities) loaded,
    required TResult Function(Object? error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<UniversityModel> universities)? loaded,
    TResult Function(Object? error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<UniversityModel> universities)? loaded,
    TResult Function(Object? error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UniversitiesInitialState value) initial,
    required TResult Function(_UniversitiesLoadedState value) loaded,
    required TResult Function(_UniversitiesErrorState value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UniversitiesInitialState value)? initial,
    TResult Function(_UniversitiesLoadedState value)? loaded,
    TResult Function(_UniversitiesErrorState value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UniversitiesInitialState value)? initial,
    TResult Function(_UniversitiesLoadedState value)? loaded,
    TResult Function(_UniversitiesErrorState value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UniversitiesStateCopyWith<$Res> {
  factory $UniversitiesStateCopyWith(
          UniversitiesState value, $Res Function(UniversitiesState) then) =
      _$UniversitiesStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$UniversitiesStateCopyWithImpl<$Res>
    implements $UniversitiesStateCopyWith<$Res> {
  _$UniversitiesStateCopyWithImpl(this._value, this._then);

  final UniversitiesState _value;
  // ignore: unused_field
  final $Res Function(UniversitiesState) _then;
}

/// @nodoc
abstract class _$$_UniversitiesInitialStateCopyWith<$Res> {
  factory _$$_UniversitiesInitialStateCopyWith(
          _$_UniversitiesInitialState value,
          $Res Function(_$_UniversitiesInitialState) then) =
      __$$_UniversitiesInitialStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UniversitiesInitialStateCopyWithImpl<$Res>
    extends _$UniversitiesStateCopyWithImpl<$Res>
    implements _$$_UniversitiesInitialStateCopyWith<$Res> {
  __$$_UniversitiesInitialStateCopyWithImpl(_$_UniversitiesInitialState _value,
      $Res Function(_$_UniversitiesInitialState) _then)
      : super(_value, (v) => _then(v as _$_UniversitiesInitialState));

  @override
  _$_UniversitiesInitialState get _value =>
      super._value as _$_UniversitiesInitialState;
}

/// @nodoc

class _$_UniversitiesInitialState implements _UniversitiesInitialState {
  const _$_UniversitiesInitialState();

  @override
  String toString() {
    return 'UniversitiesState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UniversitiesInitialState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<UniversityModel> universities) loaded,
    required TResult Function(Object? error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<UniversityModel> universities)? loaded,
    TResult Function(Object? error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<UniversityModel> universities)? loaded,
    TResult Function(Object? error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UniversitiesInitialState value) initial,
    required TResult Function(_UniversitiesLoadedState value) loaded,
    required TResult Function(_UniversitiesErrorState value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UniversitiesInitialState value)? initial,
    TResult Function(_UniversitiesLoadedState value)? loaded,
    TResult Function(_UniversitiesErrorState value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UniversitiesInitialState value)? initial,
    TResult Function(_UniversitiesLoadedState value)? loaded,
    TResult Function(_UniversitiesErrorState value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _UniversitiesInitialState implements UniversitiesState {
  const factory _UniversitiesInitialState() = _$_UniversitiesInitialState;
}

/// @nodoc
abstract class _$$_UniversitiesLoadedStateCopyWith<$Res> {
  factory _$$_UniversitiesLoadedStateCopyWith(_$_UniversitiesLoadedState value,
          $Res Function(_$_UniversitiesLoadedState) then) =
      __$$_UniversitiesLoadedStateCopyWithImpl<$Res>;
  $Res call({List<UniversityModel> universities});
}

/// @nodoc
class __$$_UniversitiesLoadedStateCopyWithImpl<$Res>
    extends _$UniversitiesStateCopyWithImpl<$Res>
    implements _$$_UniversitiesLoadedStateCopyWith<$Res> {
  __$$_UniversitiesLoadedStateCopyWithImpl(_$_UniversitiesLoadedState _value,
      $Res Function(_$_UniversitiesLoadedState) _then)
      : super(_value, (v) => _then(v as _$_UniversitiesLoadedState));

  @override
  _$_UniversitiesLoadedState get _value =>
      super._value as _$_UniversitiesLoadedState;

  @override
  $Res call({
    Object? universities = freezed,
  }) {
    return _then(_$_UniversitiesLoadedState(
      universities: universities == freezed
          ? _value._universities
          : universities // ignore: cast_nullable_to_non_nullable
              as List<UniversityModel>,
    ));
  }
}

/// @nodoc

class _$_UniversitiesLoadedState implements _UniversitiesLoadedState {
  const _$_UniversitiesLoadedState(
      {required final List<UniversityModel> universities})
      : _universities = universities;

  final List<UniversityModel> _universities;
  @override
  List<UniversityModel> get universities {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_universities);
  }

  @override
  String toString() {
    return 'UniversitiesState.loaded(universities: $universities)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UniversitiesLoadedState &&
            const DeepCollectionEquality()
                .equals(other._universities, _universities));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_universities));

  @JsonKey(ignore: true)
  @override
  _$$_UniversitiesLoadedStateCopyWith<_$_UniversitiesLoadedState>
      get copyWith =>
          __$$_UniversitiesLoadedStateCopyWithImpl<_$_UniversitiesLoadedState>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<UniversityModel> universities) loaded,
    required TResult Function(Object? error) error,
  }) {
    return loaded(universities);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<UniversityModel> universities)? loaded,
    TResult Function(Object? error)? error,
  }) {
    return loaded?.call(universities);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<UniversityModel> universities)? loaded,
    TResult Function(Object? error)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(universities);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UniversitiesInitialState value) initial,
    required TResult Function(_UniversitiesLoadedState value) loaded,
    required TResult Function(_UniversitiesErrorState value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UniversitiesInitialState value)? initial,
    TResult Function(_UniversitiesLoadedState value)? loaded,
    TResult Function(_UniversitiesErrorState value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UniversitiesInitialState value)? initial,
    TResult Function(_UniversitiesLoadedState value)? loaded,
    TResult Function(_UniversitiesErrorState value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _UniversitiesLoadedState implements UniversitiesState {
  const factory _UniversitiesLoadedState(
          {required final List<UniversityModel> universities}) =
      _$_UniversitiesLoadedState;

  List<UniversityModel> get universities;
  @JsonKey(ignore: true)
  _$$_UniversitiesLoadedStateCopyWith<_$_UniversitiesLoadedState>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UniversitiesErrorStateCopyWith<$Res> {
  factory _$$_UniversitiesErrorStateCopyWith(_$_UniversitiesErrorState value,
          $Res Function(_$_UniversitiesErrorState) then) =
      __$$_UniversitiesErrorStateCopyWithImpl<$Res>;
  $Res call({Object? error});
}

/// @nodoc
class __$$_UniversitiesErrorStateCopyWithImpl<$Res>
    extends _$UniversitiesStateCopyWithImpl<$Res>
    implements _$$_UniversitiesErrorStateCopyWith<$Res> {
  __$$_UniversitiesErrorStateCopyWithImpl(_$_UniversitiesErrorState _value,
      $Res Function(_$_UniversitiesErrorState) _then)
      : super(_value, (v) => _then(v as _$_UniversitiesErrorState));

  @override
  _$_UniversitiesErrorState get _value =>
      super._value as _$_UniversitiesErrorState;

  @override
  $Res call({
    Object? error = freezed,
  }) {
    return _then(_$_UniversitiesErrorState(
      error: error == freezed ? _value.error : error,
    ));
  }
}

/// @nodoc

class _$_UniversitiesErrorState implements _UniversitiesErrorState {
  const _$_UniversitiesErrorState({this.error});

  @override
  final Object? error;

  @override
  String toString() {
    return 'UniversitiesState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UniversitiesErrorState &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));

  @JsonKey(ignore: true)
  @override
  _$$_UniversitiesErrorStateCopyWith<_$_UniversitiesErrorState> get copyWith =>
      __$$_UniversitiesErrorStateCopyWithImpl<_$_UniversitiesErrorState>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<UniversityModel> universities) loaded,
    required TResult Function(Object? error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<UniversityModel> universities)? loaded,
    TResult Function(Object? error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<UniversityModel> universities)? loaded,
    TResult Function(Object? error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UniversitiesInitialState value) initial,
    required TResult Function(_UniversitiesLoadedState value) loaded,
    required TResult Function(_UniversitiesErrorState value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UniversitiesInitialState value)? initial,
    TResult Function(_UniversitiesLoadedState value)? loaded,
    TResult Function(_UniversitiesErrorState value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UniversitiesInitialState value)? initial,
    TResult Function(_UniversitiesLoadedState value)? loaded,
    TResult Function(_UniversitiesErrorState value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _UniversitiesErrorState implements UniversitiesState {
  const factory _UniversitiesErrorState({final Object? error}) =
      _$_UniversitiesErrorState;

  Object? get error;
  @JsonKey(ignore: true)
  _$$_UniversitiesErrorStateCopyWith<_$_UniversitiesErrorState> get copyWith =>
      throw _privateConstructorUsedError;
}
